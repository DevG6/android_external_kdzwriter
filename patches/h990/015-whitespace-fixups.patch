diff -ur kernel/msm-3.18.orig/drivers/gud/MobiCoreDriver/main.c kernel/msm-3.18/drivers/gud/MobiCoreDriver/main.c
--- kernel/msm-3.18.orig/drivers/gud/MobiCoreDriver/main.c	2016-09-17 01:59:46.000000000 -0700
+++ kernel/msm-3.18/drivers/gud/MobiCoreDriver/main.c	2017-01-08 11:57:32.747169371 -0800
@@ -612,7 +612,7 @@
 	if (err)
 		goto fail_creat_dev_admin;
 
-		return 0;
+	return 0;
 
 fail_creat_dev_admin:
 	mc_scheduler_exit();
diff -ur kernel/msm-3.18.orig/drivers/input/touchscreen/lge/lgsic/touch_sw49407_watch.c kernel/msm-3.18/drivers/input/touchscreen/lge/lgsic/touch_sw49407_watch.c
--- kernel/msm-3.18.orig/drivers/input/touchscreen/lge/lgsic/touch_sw49407_watch.c	2016-09-17 01:59:46.000000000 -0700
+++ kernel/msm-3.18/drivers/input/touchscreen/lge/lgsic/touch_sw49407_watch.c	2017-01-08 11:57:32.747169371 -0800
@@ -642,11 +642,11 @@
 	mutex_lock(&ts->lock);
 	TOUCH_I("%s start\n", __func__);
 
-    value = 1;
-    ret = sw49407_reg_write(dev, EXT_WATCH_FONT_DN_FLAG,
-        (u8*)&value, sizeof(u32));
-    if (ret)
-        goto error;
+	value = 1;
+	ret = sw49407_reg_write(dev, EXT_WATCH_FONT_DN_FLAG,
+		(u8*)&value, sizeof(u32));
+	if (ret)
+		goto error;
 
 	remained = d->watch.font_written_size;
 
diff -ur kernel/msm-3.18.orig/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c kernel/msm-3.18/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c
--- kernel/msm-3.18.orig/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c	2016-09-17 01:59:46.000000000 -0700
+++ kernel/msm-3.18/drivers/media/platform/msm/camera_v2/isp/msm_isp40.c	2017-01-08 11:57:32.751169393 -0800
@@ -209,12 +209,12 @@
 						__func__);
 					kfree(ds_settings);
 					kfree(ds_regs);
-	} else {
+				} else {
 					for (i = 0; i < ds_entries; i++)
 						msm_camera_io_w(ds_settings[i],
 							vfebase + ds_regs[i]);
-						kfree(ds_regs);
-						kfree(ds_settings);
+					kfree(ds_regs);
+					kfree(ds_settings);
 				}
 			} else {
 				kfree(ds_regs);
diff -ur kernel/msm-3.18.orig/drivers/media/platform/msm/camera_v2/sensor/proxy/vl53l010_api.c kernel/msm-3.18/drivers/media/platform/msm/camera_v2/sensor/proxy/vl53l010_api.c
--- kernel/msm-3.18.orig/drivers/media/platform/msm/camera_v2/sensor/proxy/vl53l010_api.c	2016-09-17 01:59:46.000000000 -0700
+++ kernel/msm-3.18/drivers/media/platform/msm/camera_v2/sensor/proxy/vl53l010_api.c	2017-01-08 11:57:32.759169424 -0800
@@ -601,23 +601,21 @@
 
 	LOG_FUNCTION_START("");
 
-    /* Set I2C standard mode */
-    if (Status == VL53L0_ERROR_NONE)
-        Status = VL53L0_WrByte(Dev, 0x88, 0x00);
+	/* Set I2C standard mode */
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_WrByte(Dev, 0x88, 0x00);
 
 	/* this function do nothing if it has been called before */
 	Status = VL53L010_get_info_from_device(Dev);
 
 	if (Status == VL53L0_ERROR_NONE) {
-        Revision = VL53L010_GETDEVICESPECIFICPARAMETER(Dev, Revision);
-    }
+		Revision = VL53L010_GETDEVICESPECIFICPARAMETER(Dev, Revision);
 
-    if (Status == VL53L0_ERROR_NONE) {
 		if (Revision == 0)
 			Status = VL53L010_load_additional_settings1(Dev);
 	}
 
-    /* update13_05_15 */
+	/* update13_05_15 */
 	if (Status == VL53L0_ERROR_NONE) {
 		if ((Revision <= 34) && (Revision != 32)) {
 
diff -ur kernel/msm-3.18.orig/drivers/misc/qcom/qdsp6v2/audio_amrwbplus.c kernel/msm-3.18/drivers/misc/qcom/qdsp6v2/audio_amrwbplus.c
--- kernel/msm-3.18.orig/drivers/misc/qcom/qdsp6v2/audio_amrwbplus.c	2016-09-17 01:59:47.000000000 -0700
+++ kernel/msm-3.18/drivers/misc/qcom/qdsp6v2/audio_amrwbplus.c	2017-01-08 11:57:32.751169393 -0800
@@ -106,8 +106,8 @@
 			audio->enabled);
 		if (audio->stopped == 1)
 			audio->stopped = 0;
-			break;
-		}
+		break;
+	}
 	default:
 		pr_err("%s: Unknown ioctl cmd = %d", __func__, cmd);
 		rc = -EINVAL;
diff -ur kernel/msm-3.18.orig/drivers/power/qpnp-smbcharger.c kernel/msm-3.18/drivers/power/qpnp-smbcharger.c
--- kernel/msm-3.18.orig/drivers/power/qpnp-smbcharger.c	2016-09-17 01:59:48.000000000 -0700
+++ kernel/msm-3.18/drivers/power/qpnp-smbcharger.c	2017-01-08 11:57:32.755169410 -0800
@@ -7566,7 +7566,7 @@
 		else
 			valid_id = lge_val.intval;
 
-			return valid_id;
+		return valid_id;
 	}
 
 	valid_id = false;
@@ -8983,8 +8983,8 @@
 	else
 		delay_time = CHARGING_INFORM_NORMAL_TIME;
 
-		schedule_delayed_work(&chip->charging_info_work,
-			round_jiffies_relative(msecs_to_jiffies(delay_time)));
+	schedule_delayed_work(&chip->charging_info_work,
+		round_jiffies_relative(msecs_to_jiffies(delay_time)));
 
 }
 #endif
diff -ur kernel/msm-3.18.orig/fs/sdcardfs/inode.c kernel/msm-3.18/fs/sdcardfs/inode.c
--- kernel/msm-3.18.orig/fs/sdcardfs/inode.c	2016-09-17 01:59:49.000000000 -0700
+++ kernel/msm-3.18/fs/sdcardfs/inode.c	2017-01-08 11:57:32.755169410 -0800
@@ -73,9 +73,9 @@
 	lower_dentry = lower_path.dentry;
 	lower_parent_dentry = lock_parent(lower_dentry);
 
-    err = mnt_want_write(lower_path.mnt);
-    if (err)
-        goto out_unlock;
+	err = mnt_want_write(lower_path.mnt);
+	if (err)
+		goto out_unlock;
 
 	/* set last 16bytes of mode field to 0664 */
 	mode = (mode & S_IFMT) | 00664;
@@ -174,8 +174,8 @@
 	lower_dir_dentry = lock_parent(lower_dentry);
 
 	err = mnt_want_write(lower_path.mnt);
-    if (err)
-        goto out_unlock;
+	if (err)
+		goto out_unlock;
 
 	err = vfs_unlink(lower_dir_inode, lower_dentry, NULL);
 
@@ -223,9 +223,9 @@
 	lower_dentry = lower_path.dentry;
 	lower_parent_dentry = lock_parent(lower_dentry);
 
-    err = mnt_want_write(lower_path.mnt);
-    if (err)
-        goto out_unlock;
+	err = mnt_want_write(lower_path.mnt);
+	if (err)
+		goto out_unlock;
 
 	err = vfs_symlink(lower_parent_dentry->d_inode, lower_dentry, symname);
 	if (err)
@@ -277,7 +277,7 @@
 	int fullpath_namelen;
 	int touch_err = 0;
 
-    if(!check_caller_access_to_name(dir, dentry->d_name.name, 1)) {
+	if(!check_caller_access_to_name(dir, dentry->d_name.name, 1)) {
 		printk(KERN_INFO "%s: need to check the caller's gid in packages.list\n"
 						 "  dentry: %s, task:%s\n",
 						 __func__, dentry->d_name.name, current->comm);
@@ -300,9 +300,9 @@
 	lower_dentry = lower_path.dentry;
 	lower_parent_dentry = lock_parent(lower_dentry);
 
-    err = mnt_want_write(lower_path.mnt);
-    if (err)
-        goto out_unlock;
+	err = mnt_want_write(lower_path.mnt);
+	if (err)
+		goto out_unlock;
 
 	/* set last 16bytes of mode field to 0775 */
 	mode = (mode & S_IFMT) | 00775;
@@ -403,7 +403,7 @@
 	struct path lower_path;
 	const struct cred *saved_cred = NULL;
 
-    if(!check_caller_access_to_name(dir, dentry->d_name.name, 1)) {
+	if(!check_caller_access_to_name(dir, dentry->d_name.name, 1)) {
 		printk(KERN_INFO "%s: need to check the caller's gid in packages.list\n"
 						 "  dentry: %s, task:%s\n",
 						  __func__, dentry->d_name.name, current->comm);
@@ -421,9 +421,9 @@
 	lower_dentry = lower_path.dentry;
 	lower_dir_dentry = lock_parent(lower_dentry);
 
-    err = mnt_want_write(lower_path.mnt);
-    if (err)
-        goto out_unlock;
+	err = mnt_want_write(lower_path.mnt);
+	if (err)
+		goto out_unlock;
 	err = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
 	if (err)
 		goto out;
@@ -460,9 +460,9 @@
 	lower_dentry = lower_path.dentry;
 	lower_parent_dentry = lock_parent(lower_dentry);
 
-    err = mnt_want_write(lower_path.mnt);
-    if (err)
-        goto out_unlock;
+	err = mnt_want_write(lower_path.mnt);
+	if (err)
+		goto out_unlock;
 
 	err = vfs_mknod(lower_parent_dentry->d_inode, lower_dentry, mode, dev);
 	if (err)
@@ -499,11 +499,11 @@
 	struct path lower_old_path, lower_new_path;
 	const struct cred *saved_cred = NULL;
 
-    struct sdcardfs_sb_info *sbi;
-    int mask = 0;
+	struct sdcardfs_sb_info *sbi;
+	int mask = 0;
 
-    if(!check_caller_access_to_name(old_dir, old_dentry->d_name.name, 1) ||
-        !check_caller_access_to_name(new_dir, new_dentry->d_name.name, 1)) {
+	if(!check_caller_access_to_name(old_dir, old_dentry->d_name.name, 1) ||
+		!check_caller_access_to_name(new_dir, new_dentry->d_name.name, 1)) {
 		printk(KERN_INFO "%s: need to check the caller's gid in packages.list\n"
 						 "  new dentry: %s, task:%s\n",
 						 __func__, new_dentry->d_name.name, current->comm);
@@ -533,12 +533,12 @@
 		goto out;
 	}
 
-    err = mnt_want_write(lower_old_path.mnt);
-    if (err)
-        goto out;
-    err = mnt_want_write(lower_new_path.mnt);
-    if (err)
-        goto out_drop_old_write;
+	err = mnt_want_write(lower_old_path.mnt);
+	if (err)
+		goto out;
+	err = mnt_want_write(lower_new_path.mnt);
+	if (err)
+		goto out_drop_old_write;
 
 	err = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
 			 lower_new_dir_dentry->d_inode, lower_new_dentry, NULL, 0);
@@ -548,9 +548,9 @@
 	/* Copy attrs from lower dir, but i_uid/i_gid */
 	sdcardfs_copy_inode_attr(new_dir, lower_new_dir_dentry->d_inode);
 	fsstack_copy_inode_size(new_dir, lower_new_dir_dentry->d_inode);
-    sbi = SDCARDFS_SB(new_dentry->d_sb);
-    mask = sbi->options.sdfs_mask;
-    fix_derived_permission(new_dir, mask);
+	sbi = SDCARDFS_SB(new_dentry->d_sb);
+	mask = sbi->options.sdfs_mask;
+	fix_derived_permission(new_dir, mask);
 	if (new_dir != old_dir) {
 		sdcardfs_copy_inode_attr(old_dir, lower_old_dir_dentry->d_inode);
 		fsstack_copy_inode_size(old_dir, lower_old_dir_dentry->d_inode);
@@ -704,11 +704,11 @@
 	struct path lower_path;
 	struct dentry *parent;
 
-    struct sdcardfs_sb_info *sbi;
-    int mask = 0;
+	struct sdcardfs_sb_info *sbi;
+	int mask = 0;
 
 	parent = dget_parent(dentry);
-    if(!check_caller_access_to_name(parent->d_inode, dentry->d_name.name, 0)) {
+	if(!check_caller_access_to_name(parent->d_inode, dentry->d_name.name, 0)) {
 		printk(KERN_INFO "%s: need to check the caller's gid in packages.list\n"
 						 "  dentry: %s, task:%s\n",
 						 __func__, dentry->d_name.name, current->comm);
@@ -730,9 +730,9 @@
 	 * so, on this stage, its derived permission must be
 	 * rechecked from its private field.
 	 */
-    sbi = SDCARDFS_SB(dentry->d_sb);
-    mask = sbi->options.sdfs_mask;
-    fix_derived_permission(inode, mask);
+	sbi = SDCARDFS_SB(dentry->d_sb);
+	mask = sbi->options.sdfs_mask;
+	fix_derived_permission(inode, mask);
 	mutex_unlock(&inode->i_mutex);
 
 	generic_fillattr(inode, stat);
@@ -750,8 +750,8 @@
 	struct iattr lower_ia;
 	struct dentry *parent;
 
-    struct sdcardfs_sb_info *sbi;
-    int mask = 0;
+	struct sdcardfs_sb_info *sbi;
+	int mask = 0;
 
 	inode = dentry->d_inode;
 
@@ -828,9 +828,9 @@
 	/* get attributes from the lower inode */
 	sdcardfs_copy_inode_attr(inode, lower_inode);
 	/* update derived permission of the upper inode */
-    sbi = SDCARDFS_SB(dentry->d_sb);
-    mask = sbi->options.sdfs_mask;
-    fix_derived_permission(inode, mask);
+	sbi = SDCARDFS_SB(dentry->d_sb);
+	mask = sbi->options.sdfs_mask;
+	fix_derived_permission(inode, mask);
 
 	/*
 	 * Not running fsstack_copy_inode_size(inode, lower_inode), because
diff -ur kernel/msm-3.18.orig/fs/sdcardfs/super.c kernel/msm-3.18/fs/sdcardfs/super.c
--- kernel/msm-3.18.orig/fs/sdcardfs/super.c	2016-09-17 01:59:49.000000000 -0700
+++ kernel/msm-3.18/fs/sdcardfs/super.c	2017-01-08 11:57:32.755169410 -0800
@@ -258,12 +258,12 @@
 		seq_printf(m, ",uid=%u", opts->fs_low_uid);
 	if (opts->fs_low_gid != 0)
 		seq_printf(m, ",gid=%u", opts->fs_low_gid);
-    if (opts->sdfs_gid != 0)
-        seq_printf(m, ",sdfs_gid=%u", opts->sdfs_gid);
-    if (opts->sdfs_mask != 0)
-        seq_printf(m, ",sdfs_mask%u", opts->sdfs_mask);
-    if (opts->multi_user != 0)
-        seq_printf(m, ",multi_user");
+	if (opts->sdfs_gid != 0)
+		seq_printf(m, ",sdfs_gid=%u", opts->sdfs_gid);
+	if (opts->sdfs_mask != 0)
+		seq_printf(m, ",sdfs_mask%u", opts->sdfs_mask);
+	if (opts->multi_user != 0)
+		seq_printf(m, ",multi_user");
 
 	if (opts->reserved_mb != 0)
 		seq_printf(m, ",reserved=%uMB", opts->reserved_mb);
